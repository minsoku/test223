<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VR ë¦¬ë“¬ ê²Œì„ - Babylon.js</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background: #000;
      }
      canvas {
        width: 100%;
        height: 100vh;
        display: block;
      }
      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        z-index: 100;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 8px;
        max-width: 400px;
      }
      #info h1 {
        margin: 0 0 10px 0;
        color: #4caf50;
      }
      #info p {
        margin: 10px 0;
        line-height: 1.5;
      }
      #enterVR {
        background: #4caf50;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        margin: 10px 5px 10px 0;
      }
      #enterVR:hover {
        background: #45a049;
      }
      #backButton {
        background: #2196f3;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        margin: 10px 5px 10px 0;
      }
      #backButton:hover {
        background: #1976d2;
      }
      .instructions {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 6px;
        margin: 15px 0;
      }
      .instructions h3 {
        margin: 0 0 10px 0;
        color: #ffd700;
      }
      .instructions ul {
        margin: 10px 0;
        padding-left: 20px;
      }
      .instructions li {
        margin: 5px 0;
      }
      #audioWarning {
        background: rgba(255, 165, 0, 0.2);
        border: 1px solid #ffa500;
        padding: 10px;
        border-radius: 6px;
        margin: 10px 0;
        color: #ffa500;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <h1>ğŸµ VR ë¦¬ë“¬ ê²Œì„</h1>
      <p>Babylon.jsë¥¼ ì‚¬ìš©í•œ ë¬¼ë¦¬ ê¸°ë°˜ VR ë“œëŸ¼ ê²Œì„ì…ë‹ˆë‹¤.</p>

      <div id="audioWarning">
        âš ï¸ VR ëª¨ë“œ ì§„ì… ì‹œ ë°˜ë“œì‹œ ì‚¬ìš´ë“œë¥¼ í™œì„±í™”í•˜ì„¸ìš”!
      </div>

      <div class="instructions">
        <h3>ğŸ® ê²Œì„ ë°©ë²•:</h3>
        <ul>
          <li>VR ëª¨ë“œì—ì„œ 3ê°œì˜ êµ¬ìŠ¬ì´ ìœ„ì—ì„œ ë–¨ì–´ì§‘ë‹ˆë‹¤</li>
          <li>ì•ìª½ì˜ ë“œëŸ¼ ìƒ˜í”Œë“¤ì„ ì¡ì•„ì„œ ìœ„ì¹˜ì‹œí‚¤ì„¸ìš”</li>
          <li>êµ¬ìŠ¬ì´ ë“œëŸ¼ì— ë–¨ì–´ì§€ë©´ ë¦¬ë“¬ì´ ë§Œë“¤ì–´ì§‘ë‹ˆë‹¤</li>
          <li>ì† ì¶”ì ê³¼ ì»¨íŠ¸ë¡¤ëŸ¬ ëª¨ë‘ ì§€ì›ë©ë‹ˆë‹¤</li>
        </ul>
      </div>

      <div class="instructions">
        <h3>ğŸ•¹ï¸ ì¡°ì‘ë²•:</h3>
        <ul>
          <li><strong>ì»¨íŠ¸ë¡¤ëŸ¬:</strong> íŠ¸ë¦¬ê±° ë˜ëŠ” ìŠ¤í€´ì¦ˆ ë²„íŠ¼ìœ¼ë¡œ ì¡ê¸°</li>
          <li><strong>ì† ì¶”ì :</strong> ì„ íƒ ì œìŠ¤ì²˜ë¡œ ì¡ê¸°</li>
          <li><strong>ë“œëŸ¼ ì¢…ë¥˜:</strong> ë°•ìŠ¤, êµ¬, ì‹¤ë¦°ë” 3ê°€ì§€</li>
        </ul>
      </div>

      <button id="enterVR">VR ëª¨ë“œ ì‹œì‘</button>
      <button id="backButton" onclick="window.location.href='index.html'">
        ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°
      </button>
    </div>

    <canvas id="canvas"></canvas>

    <!-- Babylon.js ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>

    <script>
      // Canvas ìƒì„±
      const canvas = document.getElementById("canvas");
      const engine = new BABYLON.Engine(canvas, true);

      // VR ë¦¬ë“¬ ê²Œì„ ìƒì„± í•¨ìˆ˜ (test.js ê¸°ë°˜)
      var createScene = async function () {
        let timeout;
        const mats = [];
        const positions = [];

        // ê¸°ë³¸ ì”¬ ìƒì„±
        var scene = new BABYLON.Scene(engine);

        // ì¹´ë©”ë¼ ìƒì„±
        var camera = new BABYLON.FreeCamera(
          "camera1",
          new BABYLON.Vector3(0, 2, 0),
          scene
        );
        camera.setTarget(new BABYLON.Vector3(0, 0, 1));
        camera.attachControl(canvas, true);
        scene.activeCamera = camera;

        // ì¡°ëª… ì„¤ì •
        var light = new BABYLON.DirectionalLight(
          "light",
          new BABYLON.Vector3(0, -0.5, 1.0),
          scene
        );
        light.position = new BABYLON.Vector3(0, 5, -6);

        // ë¬¼ë¦¬ ì—”ì§„ í™œì„±í™”
        scene.enablePhysics(
          undefined,
          new BABYLON.CannonJSPlugin(undefined, 80)
        );

        // ê·¸ë¦¼ì ìƒì„±ê¸°
        const shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
        shadowGenerator.useBlurExponentialShadowMap = true;
        shadowGenerator.blurKernel = 32;

        // í•˜ì´ë¼ì´íŠ¸ ë ˆì´ì–´
        const hl = new BABYLON.HighlightLayer("hl1", scene);

        // ê¸°ë³¸ í™˜ê²½ ìƒì„±
        const environment = scene.createDefaultEnvironment();

        // 3ê°€ì§€ ì¬ì§ˆ ìƒì„±
        const mat1 = new BABYLON.StandardMaterial("mat1", scene);
        mat1.diffuseColor = BABYLON.Color3.Blue();
        const mat2 = new BABYLON.StandardMaterial("mat2", scene);
        mat2.diffuseColor = BABYLON.Color3.Yellow();
        const mat3 = new BABYLON.StandardMaterial("mat3", scene);
        mat3.diffuseColor = BABYLON.Color3.Red();
        mats.push(mat1, mat2, mat3);

        // êµ¬ìŠ¬ì´ ë–¨ì–´ì§ˆ ìœ„ì¹˜ë“¤
        positions.push(
          new BABYLON.Vector3(-0.5, 2, 0),
          new BABYLON.Vector3(0, 2, 0.5),
          new BABYLON.Vector3(0.5, 2, 0)
        );

        // XR ê²½í—˜ ìƒì„±
        const xrHelper = await scene.createDefaultXRExperienceAsync({
          floorMeshes: [environment.ground],
          disableTeleportation: true,
        });

        xrHelper.pointerSelection.displayLaserPointer = false;
        xrHelper.pointerSelection.displaySelectionMesh = false;

        // í•¸ë“œ íŠ¸ë˜í‚¹ ì§€ì›
        const featureManager = xrHelper.baseExperience.featuresManager;
        featureManager.enableFeature(
          BABYLON.WebXRFeatureName.HAND_TRACKING,
          "latest",
          {
            xrInput: xrHelper.input,
          },
          true,
          false
        );

        // ë–¨ì–´ì§„ êµ¬ìŠ¬ ì •ë¦¬
        scene.onBeforeRenderObservable.add(() => {
          scene.getMeshesById("drop").forEach((drop) => {
            if (drop.position.y < -0.5) {
              drop.dispose();
            }
          });
        });

        // êµ¬ìŠ¬ ìƒì„± í•¨ìˆ˜
        const createDrop = (idx) => {
          const s = BABYLON.SphereBuilder.CreateSphere("drop", {
            diameter: 0.08,
          });
          s.material = mats[idx];
          s.physicsImpostor = new BABYLON.PhysicsImpostor(
            s,
            BABYLON.PhysicsImpostor.SphereImpostor,
            {
              mass: 0.5,
              friction: 0.01,
              restitution: 0.6,
            }
          );
          s.position.copyFrom(positions[idx]);

          // ë“œëŸ¼ê³¼ì˜ ì¶©ëŒ ê°ì§€
          s.physicsImpostor.registerOnPhysicsCollide(
            scene.getMeshesById("drum").map((m) => m.physicsImpostor),
            (col, against) => {
              hl.addMesh(against.object, s.material.diffuseColor);
              setTimeout(() => {
                hl.removeMesh(against.object);
              }, 200);
            }
          );
          shadowGenerator.addShadowCaster(s);
        };

        // ì—°ì†ìœ¼ë¡œ êµ¬ìŠ¬ ìƒì„±
        const createDrops = () => {
          [0, 1, 2].forEach(createDrop);
          timeout = setTimeout(createDrops, 2000); // 30 BPM
        };

        // ë“œëŸ¼ ë³µì œ í•¨ìˆ˜
        const makeDrumsGreatAgain = (cloneFrom) => {
          const drumMesh = cloneFrom.clone("drum");
          shadowGenerator.addShadowCaster(drumMesh);
          drumMesh.id = "drum";
          drumMesh.physicsImpostor = new BABYLON.PhysicsImpostor(
            drumMesh,
            cloneFrom.metadata.impostorType,
            { mass: 0, friction: 0.01, restitution: 0.6 }
          );
          return drumMesh;
        };

        // VR ì„¸ì…˜ ì‹œì‘ ì‹œ êµ¬ìŠ¬ ë–¨ì–´ëœ¨ë¦¬ê¸° ì‹œì‘
        xrHelper.baseExperience.sessionManager.onXRSessionInit.add(() => {
          createDrops();
        });

        // VR ì„¸ì…˜ ì¢…ë£Œ ì‹œ íƒ€ì´ë¨¸ ì •ë¦¬
        xrHelper.baseExperience.sessionManager.onXRSessionEnded.add(() => {
          clearTimeout(timeout);
        });

        // 3ê°€ì§€ ë“œëŸ¼ ìƒ˜í”Œ ìƒì„±
        const drum1 = BABYLON.BoxBuilder.CreateBox("drumSample", {
          depth: 0.1,
          height: 0.2,
          width: 0.2,
        });
        drum1.position.set(0, 1, 0.3);
        drum1.metadata = { impostorType: BABYLON.PhysicsImpostor.BoxImpostor };

        const drum2 = BABYLON.SphereBuilder.CreateSphere("drumSample", {
          diameter: 0.2,
        });
        drum2.position.set(-0.3, 1, 0.3);
        drum2.metadata = {
          impostorType: BABYLON.PhysicsImpostor.SphereImpostor,
        };

        const drum3 = BABYLON.MeshBuilder.CreateCylinder("drumSample", {
          diameter: 0.2,
          height: 0.1,
        });
        drum3.position.set(0.3, 1, 0.3);
        drum3.metadata = {
          impostorType: BABYLON.PhysicsImpostor.CylinderImpostor,
        };

        // ì¡ê¸° ê¸°ëŠ¥
        const checkGrab = (grab, grabbingMesh) => {
          if (grab) {
            // ë“œëŸ¼ ìƒ˜í”Œê³¼ì˜ êµì°¨ í™•ì¸
            [drum1, drum2, drum3].forEach((sample) => {
              if (sample.intersectsMesh(grabbingMesh)) {
                makeDrumsGreatAgain(sample);
              }
            });

            // ê¸°ì¡´ ë“œëŸ¼ë“¤ê³¼ì˜ êµì°¨ í™•ì¸
            const drums = scene.getMeshesById("drum");
            drums.forEach((d) => {
              if (d.intersectsMesh(grabbingMesh)) {
                hl.addMesh(d, BABYLON.Color3.Green());
                d.setParent(grabbingMesh);
              }
            });
          } else {
            // ì¡ê¸° í•´ì œ
            const drums = scene.getMeshesById("drum");
            drums.forEach((d) => {
              if (d.parent === grabbingMesh) {
                hl.removeMesh(d);
                d.setParent(null);
              }
            });
          }
        };

        // ì»¨íŠ¸ë¡¤ëŸ¬ ìŠ¤í€´ì¦ˆ ë²„íŠ¼ ì§€ì›
        xrHelper.input.onControllerAddedObservable.add((controller) => {
          controller.onMeshLoadedObservable.addOnce((rootMesh) => {
            shadowGenerator.addShadowCaster(rootMesh, true);
          });

          controller.onMotionControllerInitObservable.add(() => {
            const squeeze =
              controller.motionController.getComponentOfType("squeeze");
            [squeeze].forEach((component) => {
              if (!component) return;

              component.onButtonStateChangedObservable.add(() => {
                if (component.changes.pressed) {
                  checkGrab(component.pressed, controller.pointer);
                }
              });
            });
          });
        });

        // í¬ì¸í„° ì§€ì› (ë©”ì¸ ë²„íŠ¼ê³¼ í•¸ë“œ íŠ¸ë˜í‚¹)
        scene.onPointerObservable.add((data) => {
          const controller =
            xrHelper.pointerSelection.getXRControllerByPointerId(
              data.event.pointerId
            );
          if (controller) {
            if (data.type === BABYLON.PointerEventTypes.POINTERDOWN) {
              checkGrab(true, controller.pointer);
            } else if (data.type === BABYLON.PointerEventTypes.POINTERUP) {
              checkGrab(false, controller.pointer);
            }
          }
        }, BABYLON.PointerEventTypes.POINTERDOWN | BABYLON.PointerEventTypes.POINTERUP);

        // ì”¬ ì •ë¦¬ ì‹œ íƒ€ì´ë¨¸ í•´ì œ
        scene.onDisposeObservable.add(() => {
          if (timeout) {
            clearTimeout(timeout);
          }
        });

        return scene;
      };

      // ì”¬ ìƒì„± ë° ë Œë”ë§ ì‹œì‘
      createScene().then((scene) => {
        engine.runRenderLoop(() => {
          scene.render();
        });
      });

      // ì°½ í¬ê¸° ë³€ê²½ ì‹œ ì—”ì§„ ë¦¬ì‚¬ì´ì¦ˆ
      window.addEventListener("resize", () => {
        engine.resize();
      });

      // VR ë²„íŠ¼ ì´ë²¤íŠ¸
      document.getElementById("enterVR").addEventListener("click", async () => {
        try {
          const scene = engine.scenes[0];
          if (scene) {
            const xrHelper = scene.getEngine().scenes[0].metadata?.xrHelper;
            if (xrHelper) {
              await xrHelper.baseExperience.enterXRAsync(
                "immersive-vr",
                "local-floor"
              );
            }
          }
        } catch (error) {
          console.error("VR ëª¨ë“œ ì§„ì… ì‹¤íŒ¨:", error);
          alert(
            "VR ëª¨ë“œ ì§„ì…ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. VR í—¤ë“œì…‹ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."
          );
        }
      });
    </script>
  </body>
</html>
